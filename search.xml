<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019年度总结]]></title>
    <url>%2F2020%2F01%2F01%2F2019summary%2F</url>
    <content type="text"><![CDATA[【研三】2019年度总结（想到哪儿写到哪儿（手动狗头））转眼已经到了2019年的最后一天，感觉这一年真的是人生中特别重要的一年，有很多遗憾和难过，也有很多的收获；这是第一次写年度总结，希望通过这样一种方式，能给自己留下一些以后可以回忆的东西。 科研：小论文 + 专利 + 大论文年初花了两个月的时间，将小论文初版写完，开学之后又用了一个多月时间，就论文中的创新点，审请了专利（专利和论文都要投的话，一定要先申请专利，因为专利审核会查论文，论文审核不会查专利；只要保证论文发表的时候，专利申请已经提交应该就可以）；而后就开始了我漫长的小论文投递之旅。。。。。。在五月份中旬，在老师的推荐下，投了一个还可以的EI期刊，然后经历了两次退修，期间在老师的指导下改了n多版，终于上周被录用，明年发表，小论文从投递到发表，历时八九个月，煎熬啊（捂脸）（如果研一或者研二上有精力，还是先把小论文搞定的比较好）。然后就是大论文了，元旦之后几天要写完吧，感觉还得加班加点写几天。 工作： 实习 + 秋招研三狗必须考虑的问题，实习和找工作。今年（2019）是2月份过年，寒假开学后，就陆陆续续地开始实习的提前批,(哎呀, 当时没想到会这么早，看着很多同学开始面试了，我还没怎么准备（捂脸）)，在实验室刷题刷了一个来月之后，开始投实习简历，有顺利也有不顺利的。当时比较难过的就是，第一家面的Ali被挂掉了（A是2019年3月份就开始实习招聘，比较早，很无奈）,现在想起来，当时真的是面试没有经验，很多表现不好。而后又面了KS，DD,WB,顺利拿到实习offer,选择去WB实习了一段时间后，很幸运地被A的另一部门捞到，并很幸运地通过了面试，暑假后半段时间就到A去实习了。A的实习转正概率很高，也是我想去A实习一个主要原因。 可能是觉得实习这边转正比较稳，感觉和其他同学比起来，我的秋招好佛系（捂脸），到10月中下旬的时候，看着周围同学每天忙碌面试，我也又去面了几家。最后还是选择留在了阿里。这里给部门打个广告，如果对实时计算、大数据或者存储感兴趣的同学，欢迎找我内推哈～实习和正式应该都可以哈。关于秋招和实习的经验分享就不多说了，相关的帖子和学长分享大家应该都见过很多。最后简单说几点感想： 找实习/秋招一定要有自己的时间规划，尽量早点准备，晚了也不要慌，everything will be fine; 很多人推荐刷题，是针对马上找实习的同学；如果是研一或者本科的同学，还是要应该多考虑如何能够提升自身的能力，打好基础，个人觉得才是最重要的； 关于工作选择，互联网/国企，前端/后端/其他，等等会有很多选择，一方面，应该尽早确定自己的发展方向，好早做准备；另一方面，选择的时候不要盲目跟风，完全听信他人，还是要结合自己的实际情况，在别人的建议基础之上，有自己独立的思考和判断； 生活 年初的时候，有了Qing的联系方式。自己是个恋爱小白，一路磕磕碰碰地和Qing增进关系，追了她快10个月，终于答应可以在一起了，未来就努力对她好吧。 年初的时候定的目标，要学会游泳，夏天的时候Chen同学教了两次，之后因为有事要忙，就没有再学了，感觉再下两三次水就差不多了，明年争取学会；前几天第一次去滑雪，感觉学会了基本的方法？马马虎虎吧。 去年自学了半年的吉他，今年比较事多，基本算是荒废了，以后有时间慢慢捡起来。 9月份立的flag要读的几本书也没读完（捂脸），明年继续。 关于以后的想法 还有半年就要离开生活了七年的北邮了，多少有点不舍，珍惜还有的半年时光； 感觉自己社交能力不够强，和不熟的人在一起，比较容易尬聊，这方面的能力有待加强啊，不知道有没有什么好的方法？ 有时候感觉自己逻辑组织能力不够强，将自己大脑中的想法快速组织成语言进行表达的能力不够强，思维表达方式还得加强相关的练习啊。 关于工作的想法：工作领域相关的知识深入的学习？学英语？ 最后，希望自己和研三的同学都能顺利毕业～ 另一些想说的 上面列的更多的是收获，当然也有一些遗憾，过程当中也有很多失望难过的时候。人生就是这样，你可能觉得当下艰难，当回首往事的时候，曾经的经历都是很美好的回忆。遗憾和难过不怎么想列举，是想让自己尽量忘掉这些，人生就应该朝更加积极的一面去看待，让自己难过和遗憾的事情，都尽量抛之脑后，不去计较。 前几天看到一句话很喜欢，“坚持并不是永不动摇，而是在犹豫和退缩的时刻决定继续往前走。” 最后祝大家新年快乐，希望大家在新的一年里都能够心如所愿，心想事成～]]></content>
      <tags>
        <tag>阶段总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯算法（Backtracking）]]></title>
    <url>%2F2018%2F12%2F14%2Fbacktracking%2F</url>
    <content type="text"><![CDATA[1. 定义回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。\wikipedia : https://en.wikipedia.org/wiki/Backtracking 2.适用场景一般来讲，会设置一个递归函数，函数的参数会携带一些当前的可能解的信息，根据这些参数得出可能解或者不可能而回溯. \可以应用的场景有：N皇后、数独、集合等。\回溯算法其实是暴力求解的一种优化。 3.算法伪码来自维基百科123456789In order to apply backtracking to a specific class of problems, one must provide the data P for the particular instance of the problem that is to be solved, and six procedural parameters, root, reject, accept, first, next, and output. These procedures should take the instance data P as a parameter and should do the following:root(P): return the partial candidate at the root of the search tree.reject(P,c): return true only if the partial candidate c is not worth completing.accept(P,c): return true if c is a solution of P, and false otherwise.first(P,c): generate the first extension of candidate c.next(P,s): generate the next alternative extension of a candidate, after the extension s.output(P,c): use the solution c of P, as appropriate to the application.The backtracking algorithm reduces the problem to the call bt(root(P)), where bt is the following recursive procedure: 1234567procedure bt(c) if reject(P,c) then return if accept(P,c) then output(P,c) s ← first(P,c) while s ≠ NULL do bt(s) s ← next(P,s) 4.例子leetcode 216题 https://leetcode.com/problems/combination-sum-iii/ Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. \Example 1: \Input: k = 3, n = 7Output: [[1,2,4]] \Example 2: \Input: k = 3, n = 9Output: [[1,2,6], [1,3,5], [2,3,4]] BackTracking Solution:12345678910111213141516171819202122232425class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); //!!!有时候需要对数组排序， Arrays.sort(list); backTracing(ans, new ArrayList&lt;&gt;(), k, n, 1); return ans; &#125; private void backTracing(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; comb, int k, int n, int start) &#123; if (comb.size() == k &amp;&amp; n == 0) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(comb); ans.add(list); //!!! ans.add(new ArrayList&lt;&gt;(tempList)); return; &#125; else if (comb.size() == k || n == 0) &#123; return; &#125; else &#123; for (int i = start; i &lt;= 9 ; i++) &#123; comb.add(i); backTracing(ans, comb, k, n - i, i+1); comb.remove(comb.size() - 1); //!!! tempList.remove(tempList.size() - 1); &#125; &#125; &#125; &#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树DFS和BFS 递归/非递归方式]]></title>
    <url>%2F2018%2F12%2F13%2Fdfsandbfs%2F</url>
    <content type="text"><![CDATA[1.DFSDFS, 深度优先遍历 \（1）递归形式123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 123456789101112List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;();public List&lt;TreeNode&gt; traversal(TreeNode root) &#123; dfs(root); return list;&#125;private void dfs(TreeNode root) &#123; if (root == null) return; list.add(root); dfs(root.left); dfs(root.right);&#125; (2)非递归形式 （利用栈来递归）1234567891011121314151617public List&lt;TreeNode&gt; traversal(TreeNode root) &#123; if (root == null) return null; List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.add(root); while(!stack.empty()) &#123; TreeNode node = stack.pop(); res.add(node); if (node.right != null) &#123; stack.push(node.right); &#125; if (node.left != null) &#123; stack.push(node.left); &#125; &#125; return res;&#125; 2.BFSBFS，广度优先遍历，对应二叉树的层级遍历 \(1)非递归形式 （利用队列实现遍历）123456789101112131415161718192021222324252627282930313233public List&lt;TreeNode&gt; traversal(TreeNode root) &#123; if (root == null) return null; return bfs(root); &#125; private List&lt;TreeNode&gt; bfs(TreeNode root) &#123; //if (root == null) return null; int curNum = 1; //维护当前层的node数量 int nextNum = 0; //维护下一层的node数量 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()) &#123; TreeNode node = queue.poll(); list.add(node); curNum--; if (node.left != null) &#123; queue.add(node.left); nextNum++; &#125; if (node.right != null) &#123; queue.add(node.right); nextNum++; &#125; if (curNum == 0) &#123; curNum = nextNum; nextNum = 0; &#125; &#125; return list; &#125; (2)递归形式 \这里所谓的bfs递归形式，是利用dfs的递归形式，在递归过程中记录每个node的level，然后将属于一个level的node放到一list里面12345678910111213141516171819public List&lt;List&lt;TreeNode&gt;&gt; traversal(TreeNode root) &#123; if (root == null) return null; List&lt;List&lt;TreeNode&gt;&gt; list = new ArrayList&lt;&gt;(); dfs(root, 0, list); return list;&#125;private void dfs(TreeNode root, int level, List&lt;List&lt;TreeNode&gt;&gt; list) &#123; if (root == null) return; if (level &gt;= list.size()) &#123; List&lt;TreeNode&gt; subList = new ArrayList&lt;&gt;(); subList.add(root); list.add(subList); &#125; else &#123; list.get(level).add(root); &#125; dfs(root.left, level+1, list); dfs(root.right, level+1, list);&#125; 3. 二叉树的中序遍历（1）递归形式123456public void in-order(TreeNode root) &#123; if (root == null) return; in-order(root.left); visit(root.val); in-order(root.right);&#125; (2)非递归形式123456789101112public void in-order(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while (!stack.isEmpty() || root != null) &#123; while (root != null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); visit(root); root = root.right; &#125;&#125; 图的深度优先遍历和广度优先遍历，和二叉树的dfs、bfs原理的相同的。一般，深度优先遍历利用栈来实现（或者递归），广度优先遍历利用队列来实现。 list.add(index, element):在index处添加元素element, 原先该位置的元素和后续的元素会后移list.set(index, element):替换index处的元素，替换为element]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java堆上的对象]]></title>
    <url>%2F2018%2F12%2F12%2Fjvm%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[1.对象的创建（new Object） 创建过程：先检查能否在常量池中定位到一个类的符号引用，并且检查其代表的类是否被加载、解析和初始化过；若无，执行类加载过程；然后为新生对象分配内存（类加载完成后即可确定对象大小）;内存分配完后，内存空间初始化为零；接下来，对对象的类信息、类的元数据信息、对象哈希码、GC分代年龄进行设置（这些信息存放在对象头中（Object Header））；然后执行\&lt;init>方法（按照程序员的意愿进行初始化）; java堆上内存分配的两种方式：”指针碰撞“（中间一个指针作为空闲内存和用过内存的分界点）、”空闲列表“（列表记录哪些内存块可用），采用哪种方式取决于垃圾收集器是否带有压缩整理功能。 分配内存时考虑线程安全问题：CAS失败重试，或者使用本地线程分配缓冲（TLAB）(类似于ThreadLocal)2.对象的内存布局 3个区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）. 对象头； 两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等；另一部分是类型指针，即对象指向类元数据的指针。 如果对象是Java数组，对象头中需要记录数组长度3.对象的访问定位通过栈上reference数据来操作，主流的访问方式两种： 句柄：reference存储的是句柄地址，句柄池中的句柄包含了对象实例数据和类型数据的地址信息 直接指针访问：reference中存放的直接就是对象地址。 对比：句柄方式稳定，对象移动时，只需改变句柄中的实例数据指针，reference不用变；直接指针方式速度更快，因为节省了一次指针定位的时间开销。Sun HotSpot使用指针方式。 String.intern()是一个Native方法，作用：若字符串常量池中已经包含了一个等于String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。\StirngBuilder创建的字符串实例在Java堆上。]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机运行时内存区域]]></title>
    <url>%2F2018%2F12%2F12%2Fjvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区 （前3个为线程私有，后2个为线程共享） （1）程序计数器当前线程所执行的字节码的行号指示器；通过改变这个计数器的值来选取下一条需要执行的字节码指令；分支、循环、跳转、异常处理、线程恢复等功能依赖其完成；线程切换后能恢复到正确的执行位置，故每个线程需要一个独立的程序计数器，即“线程私有”. （2）Java虚拟机栈 Java Virtual Machine Stacks; 也就是通常所说的“栈”；线程私有； 存在数据结构–栈帧（Stack Frame）,用于存储局部变量表、操作数栈、方法出口等；局部变量表中存放了编译期可知的基本数据类型（boolean,int….）、对象引用（reference,可以理解为指向对象起始位置的引用指针，或者代表对象的句柄） 存在两种异常： 1）StackOverflowError(栈溢出)： 请求栈深度大于虚拟机栈深度 2）OutOfMemoryError(OOM): 动态扩展内存时，无法申请到足够的内存（3）本地方法栈与虚拟机栈作用类似；虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机使用到底Native方法服务； 也会抛出StackOverflowError和OutOfMemoryError异常（4）Java堆 Java Heap；所有线程共享的一块内存区域；唯一目的：存放对象实例（对象实例和数组）； java堆是垃圾收集器管理的主要区域；一般采用分代收集算法；细分为：新生代和老年代，再细致点有Eden空间、From Survivor空间、To Survivor空间等；某些情况下，Java堆坑可能划分出多个线程私有的分配缓冲区（TLAB）； 可以通过-Xmx和-Xms控制堆大小；当堆内存无法扩展时，会抛出OOM（5）方法区 线程共享的内存区域；用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；在HotSpot虚拟机中称为“永久代” 运行时常量池是方法区的一部分， 用于存放编译器生成的各种字面量和符号引用；运行时也可能将新的常量放入池中，例如String的intern()方法 jdk8取消了永久代，存储在永久代的部分数据就已经转移到Java Heap或者Native memory，符号引用(Symbols)转移到了native memory；字符串常量池(interned strings)转移到了Java heap；类的静态变量(class statics)转移到了Java heap;方法存放于元空间(Metaspace) 注：直接内存（Direct Memory）：不是虚拟机中的内存区域；NIO中基于通道（Channel）和缓冲区（Buffer）的IO方式，可以使用Native函数库分配对外内存，然后通过DirectByteBuffer作为引用对其操作，不会收到堆大小的限制。]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的遍历总结]]></title>
    <url>%2F2018%2F03%2F27%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[二叉树的前序遍历（1）递归形式123456public void preorderTraversal(TreeNode root) &#123; if (root == null) return; visit(root); preorderTraversal(root.left); preorderTraversal(root.right);&#125; (2)非递归形式方式一: 用栈来只保存右节点:12345678910111213public void preorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (root != null) &#123; visit(root); if (root.right != null) &#123; stack.push(root.left); &#125; root = root.left; if (root == null &amp;&amp; !stack.isEmpty()) &#123; root = stack.pop(); &#125; &#125;&#125; 方式二：用栈保存两个子节点:123456789101112131415public void preorderTraversal(TreeNode root) &#123; if (root == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) &#123; TreeNode node = stack.pop(); visit(node); if (node.right != null) &#123; stack.push(node.right); &#125; if(node.left != null) &#123; stack.push(node.left); &#125; &#125;&#125; 二叉树后序遍历（1）递归1234567public void postOrder(TreeNode root) &#123; if (root = null) return; postOrder(root.left); postOrder(root.right); visit(root);&#125;` （2）非递归按照“头右左”进行遍历，然后翻转1234567891011121314151617public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); if (root == null) return list; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) &#123; TreeNode node = stack.pop(); list.addFirst(node.val); if (node.left != null) &#123; stack.push(node.left); &#125; if (node.right != null) &#123; stack.push(node.right); &#125; &#125; return list; &#125; 多叉树的遍历（1）多叉树定义1234567891011class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val,List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;; （2）多叉树前序遍历 非递归123456789101112public void preOrder(Node root) &#123; if (root == null) reutrn; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; Node node = stack.pop(); visit(node); for (int i = node.children.size() - 1; i &gt;= 0; i--) &#123; stack.push(node.children.get(i)); &#125; &#125;&#125; (3)多叉树的层次遍历12345678910111213141516171819public List&lt;List&lt;Integer&gt; levelOrder(Node root) &#123; List&lt;List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if (root == null) return ans; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); int len = queue.size(); for (int i = 0; i &lt; len; i++) &#123; Node node = queue.poll(); temp.add(node.val); for (Node child : node.children) &#123; queue.offer(child); &#125; &#125; ans.add(temp); &#125; return ans;&#125; （4）多叉树的后序遍历 非递归按照“头右左”遍历 ，然后再翻转123456789101112131415public List&lt;Integer&gt; postOrder(Node root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) return list; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; Node node = stack.pop(); list.add(node.val); for (Node child : node.children) &#123; stack.push(child); &#125; &#125; Collections.reverse(list); return list;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[JVM类加载器]]></title>
    <url>%2F2018%2F03%2F15%2FJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[JVM提供了三大内置的类加载器，BootStrap ClassLoader —&gt; Ext ClassLoader —–&gt; Application ClassLoader (—–&gt; Custom ClassLoader)他们之间严格遵守父委托的机制； 1. 类加载器（1）根类加载器（Bootstrap类加载器）最顶层加载器，C++编写，负责虚拟机核心类库的加载，例如java.lang包，通过-Xbootclasspath指定其路径 （2）扩展类加载器其父加载器为根加载器，主要用于加载JAVA_HOME下jre\lb\ext子目录中的类库 （3）系统类加载器其负责加载classpath下的类库资源，其父加载器是扩展类加载器，同时也是自定义类加载器的默认父加载器，其加载路径一般通过-classpath或者-cp指定 （4）自定义类加载器应用：OSGI、Tomcat的容器隔离 2.双亲委托机制(1)双亲委托双亲委托机制，也称为父委托机制——-当一个类加载器被调用loadClass之后，它并不会直接将其加载，而是先交给当前类加载器的父类加载器尝试加载直到最顶层的父加载器，然后依次向下进行加载。 打破双亲委托机制的方法：（1）可以绕过系统类加载器，直接将扩展类加载器作为MyClassLoader的父加载器；（2）在构造MyCLassLoader的时候指定其父类加载器为null； 破坏双亲委托机制的应用：热部署—–热部署首先要卸载加载该模块的所有Class的类加载器，卸载类加载器会导致所有类的卸载，由于不能对三大内置加载器进行卸载，只有通过控制自定类加载器才能做到这一点。 （2）命名空间类加载器命名空间，由该加载器及其所有的父加载器所有构成；使用不同的类加载器，或者同一个类加载器的不同实例，去加载同一个class，则会在堆内存和方法区产生多个class的对象。 在JVM运行时class会有一个运行时包，运行时包是由类加载器的命名空间和类的全限定名称共同组成的，例如：BootstrapClassLoader.ExtClassLoader.AppClassLoader.MyClassLoader.com.ljz.concurrent.chapter10.Test 在类的加载过程中，所有参与的类加载器，即使没有亲自加载过该类，也会被标识为该类的初始类加载器（一个列表维护） （3）类的卸载某个对象在堆内存如果没有其他地方引用则会在垃圾回收器线程进行GC的时候被回收；而JVM规定Class只有满足一下3个条件才会被GC回收（类卸载）：（a）该类所有实例都已经被GC；（b）加载该类的ClassLoader实例被回收；（c）该类的class实例没有在其他地方被引用；]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中类的加载过程]]></title>
    <url>%2F2018%2F03%2F14%2FJava%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ClassLoader的主要职责是负责加载各种class文件到JVM中，并且在JVM中生成构成这个类的各个数据结构，然后时期分布在JVM的对应内存区域中。 类的加载过程一般分为加载阶段、连接阶段和初始化阶段。 1.加载阶段主要负责查找并且加载类的二进制数据文件（class文件）;然后将该字节流所代表的静态存储结构转换为方法区中运行时的数据结构，并且在堆内存中生成一个该类的java.lang.Class对象，作为访问方法区数据结构的入口。类加载的最终产物就是堆内存中的class对象 2.连接阶段（1）验证确保类文件的正确性，例如class版本、魔数是否正确（2）准备为类的静态变量分配内存，并且为其初始化默认值。类变量的内存会被分配到方法区中；（3）解析把类中的符合引用转换为直接引用。解析过程主要针对类接口、字段、类方法和接口方法这四类中进行。 3. 初始化阶段为类的静态变量赋予正确的初始值（代码编写阶段给定的值）,即执行方法；静态语句块只能对后面的静态变量进行赋值，但是不能对其进行访问；JVM保证了方法在多线程的执行环境下的同步语义； 4.注意事项（1）JVM对类的初始化是一个延迟的机制（lazy的方式），当一个类在首次（主动）使用的时候才会被初始化。（2）通过子类使用父类的静态变量只会导致父类的初始化，子类则不会被初始化。（3）类的被动使用，不会导致类的加载和初始化。例如，构造某个类的数组时并不会导致该类的初始化（仅仅在堆内存开辟了一段连续的地址空间）（4）引用类的静态常量不会导致类的初始化，例如1public final static int MAX = 50;]]></content>
      <tags>
        <tag>jvm</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 中的Integer Pool 和 autoboxing-same-value-to-different-objects问题]]></title>
    <url>%2F2017%2F11%2F07%2FJavaInteger%2F</url>
    <content type="text"><![CDATA[##1. 遇到问题昨天刷题的时候遇到一个很有趣的整数比较的问题, 整理如下：（1）123int i = 127;int j = 127;System.out.println(i == j); 123 int i = 128;int j = 128;System.out.println(i == j); 这两个输出应该都是true，没有问题。（2）123 Integer i = 127;Integer j = 127;System.out.println(i == j); 123 Integer i = 128;Integer j = 128;System.out.println(i == j); 第一个输出的是true, 第二个输出的是false, 这里就比较有意思了，哈哈~（3）123 Integer i = new Integer(127);Integer j = new Integer(127);System.out.println(i == j); 123 Integer i = new Integer(128);Integer j = new Integer(128);System.out.println(i == j); 这两个输出的都是false, emmmmmmmmmm, 是不是有点懵圈。。。。。 ##2. 解决问题首先，应该知道java中的自动装箱和自动拆箱机制。简而言之，就是在Java中，jvm会自动实现基本数据类型和与之相对应的类的之间的自动转换。例如int和Integer之间能够自由的转换。 其次，应该明白对象之间用“==”比较，比较的是内存中的对象是否一样（可以理解为地址是否一样）。 然后，对于第一种情况，两个int之间的比较，比较的是数值，符合我们的常规认识。 对于第二种情况，127之间的比较返回true, 128之间的比较返回false，是因为jvm中包含一个整数池（pool of Integer values ） ，这个Integer Pool只包含-128 - 127。所以当创建一个-128到127之间的Integer时，会自动引用池中的对象，故127之间的比较返回true，而创建小于-128或大于127的Integer时，则会另外单独创建，所有两个128是不同的对象，他们之间的比较自然返回false。对于第三种情况，采用 new关键字创建整数对象时，会在内存中创建不同的对象，所以这种情况下，不管value大小，他们之间的比较必然返回false。 ##3.总结（1）整数之间直接用“==”比较大小，可能会出现autoboxing-same-value-to-different-objects问题；（2）int之间用”==”比较，比较的是二者值是否相同；（3）jvm中有一个Integer Pool，包含-128 - 127之间的整数对象。当采用直接赋值的方法创建Integer时，能用池中对象直接表示的，会继续引用池中的对象，超出范围的才会创建新的对象（这也是jvm节省内存空间的一种策略）；（4）采用new关键字创建Integer对象时，会创建新的对象，而不是引用整数池中的对象。 ##4. Objects.equals()方法尝试了一下，不用“==”进行上述的比较，而用Objects.equals()方法进行上述的比较。1234567891011121314151617181920212223 int i1 = 127;int j1 = 127;System.out.println(Objects.equals(i1, j1));int i2 = 128;int j2 = 128;System.out.println(Objects.equals(i2, j2));Integer i3 = 127;Integer j3 = 127;System.out.println(Objects.equals(i3, j3));Integer i4 = 128;Integer j4 = 128;System.out.println(Objects.equals(i4, j4));Integer i5 = new Integer(127);Integer j5 = new Integer(127);System.out.println(Objects.equals(i5, j5));Integer i6 = new Integer(128);Integer j6 = new Integer(128);System.out.println(Objects.equals(i6, j6)); 上述结果输出的都是true， 如何理解呢？emmmmmmmmm……….先看Objects.equals方法的说明:1Returns true if the arguments are equal to each other and false otherwise. Consequently, if both arguments are null, true is returned and if exactly one argument is null, false is returned. Otherwise, equality is determined by using the equals method of the first argument. 所以这个方法会调用第一个参数的equals方法，上述例子中也就是调用Integer的equals方法。而Integer的equals方法比较的是两个整数的int value值是否相同，故返回true。 ##5. 参考资料http://www.devx.com/tips/Tip/42276]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 中hashCode()和equals()方法]]></title>
    <url>%2F2017%2F09%2F25%2FhashCodeAndEquals%2F</url>
    <content type="text"><![CDATA[Java中，涉及到两个对象的比较时，我们会用到hashCode()和equals()。这两个方法是Object类中定义的方法。 ###1. api中的描述(1)hashCode()hashCode()方法给对象返回一个hash code值。这个方法被用于hash tables，例如HashMap。它的性质是： 在一个Java应用的执行期间，如果一个对象提供给equals做比较的信息没有被修改的话，该对象多次调用hashCode()方法，该方法必须始终如一返回同一个integer。 如果两个对象根据equals(Object)方法是相等的，那么调用二者各自的hashCode()方法必须产生同一个integer结果。 并不要求根据equals(java.lang.Object)方法不相等的两个对象，调用二者各自的hashCode()方法必须产生不同的integer结果。然而，程序员应该意识到对于不同的对象产生不同的integer结果，有可能会提高hash table的性能。 大量的实践表明，由Object类定义的hashCode()方法对于不同的对象返回不同的integer。 (2)equals()equals()进行的内容比较，而已经不再是地址的比较。依次类推Math、Integer、Double等这些类都是重写了equals()方法的，从而进行的是内容的比较。当然，基本类型是进行值的比较。 它的性质有： 自反性（reflexive）。对于任意不为null的引用值x，x.equals(x)一定是true。 对称性（symmetric）。对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。 传递性（transitive）。对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。 一致性（consistent）。对于任意不为null的引用值x和y，如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。 对于任意不为null的引用值x，x.equals(null)返回false。 对于Object类来说，equals()方法在对象上实现的是差别可能性最大的等价关系，即，对于任意非null的引用值x和y，当且仅当x和y引用的是同一个对象，该方法才会返回true。需要注意的是当equals()方法被override时，hashCode()也要被override。按照一般hashCode()方法的实现来说，相等的对象，它们的hash code一定相等。 ###2. 总结 在Object类中，未覆盖的hashcode（）方法产生的hashcode, 可标识该对象在hash表中位置。 由于hash表可能会产生hash冲突，所以hashCode相同的对象不一等相等。 在Object类中，未覆盖的equals方法，使用“==”进行比较的，比较的是两个对象的地址是否相同。 如果两个对象equals比较为真，即两个对象相等，则两个对象的hashcode一定相同；反过来，两个对象的hashcode相同，不代表两个对象相同（有可能hash冲突），equals比较不一定为真 在hashset 或者hashMap中，新加入一个对象的时候，它会使用对象的HashCode()值来判断对象加入的位置，但同时也会与其他的已经加入的对象的HashCode作对比，如果没有相符的hashcode，Hahset或者HashMap就会假设新对象没有重复出现。如果HashCode（）相同，接下来才会比较两个对象是否真正相同。采用这种先比较hashcode才比较是否相等的方式，可以极大地提高hashset，hashmap查找插入的效率。（时间复杂度为O(1)） ###3.覆盖Object类的hashCode()和equals（）方法我们可以根据自己的需要来覆盖Object类中的hashCode()和equals（）方法。例如String中的hashcode（）和equals（）方法123456789101112131415161718192021222324252627 /** * Returns a hash code for this string. The hash code for a * &lt;code&gt;String&lt;/code&gt; object is computed as * &lt;blockquote&gt;&lt;pre&gt; * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] * &lt;/pre&gt;&lt;/blockquote&gt; * using &lt;code&gt;int&lt;/code&gt; arithmetic, where &lt;code&gt;s[i]&lt;/code&gt; is the * &lt;i&gt;i&lt;/i&gt;th character of the string, &lt;code&gt;n&lt;/code&gt; is the length of * the string, and &lt;code&gt;^&lt;/code&gt; indicates exponentiation. * (The hash value of the empty string is zero.) * * @return a hash code value for this object. */ public int hashCode() &#123; int h = hash; int len = count; if (h == 0 &amp;&amp; len &gt; 0) &#123; int off = offset; char val[] = value; for (int i = 0; i &lt; len; i++) &#123; h = 31*h + val[off++]; &#125; hash = h; &#125; return h; &#125; 123456789101112131415161718192021222324252627282930313233343536 /** * Compares this string to the specified object. The result is &#123;@code * true&#125; if and only if the argument is not &#123;@code null&#125; and is a &#123;@code * String&#125; object that represents the same sequence of characters as this * object. * * @param anObject * The object to compare this &#123;@code String&#125; against * * @return &#123;@code true&#125; if the given object represents a &#123;@code String&#125; * equivalent to this string, &#123;@code false&#125; otherwise * * @see #compareTo(String) * @see #equalsIgnoreCase(String) */ public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = count; if (n == anotherString.count) &#123; char v1[] = value; char v2[] = anotherString.value; int i = offset; int j = anotherString.offset; while (n-- != 0) &#123; if (v1[i++] != v2[j++]) return false; &#125; return true; &#125; &#125; return false; &#125; ###4. 参考资料 https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode() http://www.cnblogs.com/Qian123/p/5703507.html]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentModificationException和fail-fast机制]]></title>
    <url>%2F2017%2F09%2F23%2FConcurrentModificationException%2F</url>
    <content type="text"><![CDATA[##单线程下： ###1. ConcurrentModificationException出现的原因例子：12345678910111213141516import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class Test &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(3); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Integer integer = iterator.next(); if(integer == 3) list.remove(integer); &#125; &#125;&#125; 运行结果：1234Exception in thread &quot;main&quot; java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(Unknown Source) at java.util.ArrayList$Itr.next(Unknown Source) at leetcode.Test.main(Test.java:13) 这时出现了ConcurrentModificationException，官方文档中关于这个异常的解释如下：12345678910public class ConcurrentModificationException extends RuntimeExceptionThis exception may be thrown by methods that have detected concurrent modification of an object when such modification is not permissible.For example, it is not generally permissible for one thread to modify a Collection while another thread is iterating over it. In general, the results of the iteration are undefined under these circumstances. Some Iterator implementations (including those of all the general purpose collection implementations provided by the JRE) may choose to throw this exception if this behavior is detected. Iterators that do this are arbitrary, non-deterministic behavior at an undetermined time in the future....... 程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 ConcurrentModificationException 异常信息，从而产生 fail-fast。 Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出java.util.ConcurrentModificationException异常。 ###2. 解决办法我们可先看看以从Iterator（）方法的具体实现：12345678910111213141516171819202122232425262728293031323334353637383940414243public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;private class Itr implements Iterator&lt;E&gt; &#123; int cursor = 0; int lastRet = -1; int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size(); &#125; public E next() &#123; checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; public void remove() &#123; if (lastRet == -1) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 这段代码不想多说，可以看到next()的checkForComodification()方法中会判断modCount和 expectedModCount的值是否相等。如果你在集合遍历过程中，删除某个元素的话，会使得modCount != expectedModCount，从而抛出ConcurrentModificationException()。 解决办法:细心的朋友会发现Itr中有remove方法，我们可以调用这个方法，实现删除元素的操作，从而不会引起ConcurrentModificationException。Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。123456789101112public class Test &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(3); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Integer integer = iterator.next(); if(integer == 3) iterator.remove();//使用Iterator的remove方法 &#125; &#125;&#125; ##多线程下： ###1. 出现原因多线程下同样会出现ConcurrentModificationException(),例如：123456789101112131415161718192021222324252627282930313233343536public class Test &#123; static ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public static void main(String[] args) &#123; list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); Thread thread1 = new Thread()&#123; public void run() &#123; Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Integer integer = iterator.next(); System.out.println(integer); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; &#125;; Thread thread2 = new Thread()&#123; public void run() &#123; Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Integer integer = iterator.next(); if(integer==2) iterator.remove(); &#125; &#125;; &#125;; thread1.start(); thread2.start(); &#125;&#125; 这段代码中thread1和thread2同时用iterator 对List对集合进行遍历，同样会产生ConcurrentModificationException()。产生的原因和单线程时是类似的，同样是两个线程的异步操作使得expectedModCount和modCount的值不一样，从而产生fail-fast。 ###2. 解决办法1）在使用iterator迭代的时候使用synchronized或者Lock进行同步；2）使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。（推荐使用） CopyOnWriterArrayList所代表的核心概念就是：任何对array在结构上有所改变的操作（add、remove、clear等），CopyOnWriterArrayList都会copy现有的数据，再在copy的数据上修改，这样就不会影响COWIterator中的数据了，修改完成之后改变原有数据的引用即可。同时这样造成的代价就是产生大量的对象，同时数组的copy也是相当有损耗的，故使用CopyOnWriterArrayList会使效率有所下降。 关于CopyOnWriteArrayList可以参照：https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html 这部分我现在了解的不是很透彻，以后再来补充。 ##注意事项： Java中增强for循环（for each），底层的实现是通过Iterator迭代器模式实现的，所以它也会产生ConcurrentModificationException。 迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。 ##参考资料： http://www.cnblogs.com/dolphin0520/p/3933551.html http://www.hollischuang.com/archives/1776 https://docs.oracle.com/javase/7/docs/api/java/util/ConcurrentModificationException.html http://blog.csdn.net/chenssy/article/details/38151189]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floyd's Cycle Detection Algorithm（Floyd判圈算法）]]></title>
    <url>%2F2017%2F09%2F01%2FFloyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[###1. 什么是Floyd判圈算法？Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。 ###2. 算法描述如果有限状态机、迭代函数或者链表上存在环，那么在某个环上以不同速度前进的2个指针必定会在某个时刻相遇。同时显然地，如果从同一个起点(即使这个起点不在某个环上)同时开始以不同速度前进的2个指针最终相遇，那么可以判定存在一个环，且可以求出2者相遇处所在的环的起点与长度。 Floyd Cycle Detection Algorithm主要解决三个问题： 检测是否有环； 如果有环，求环的起点； 如果有环，求环的长度；####(1)检测是否有环基本思想：这个可以用跑步来解释，假设两个人从同一起点出发（不从同一起点也可以），以不同的速度向前跑，最终快的人一定会追上慢的人（套圈）。可以将速度快的人换做兔子，速度慢的人换做乌龟，就变成龟兔赛跑了，23333……. 基于上述思想，我们可以这样检测是否有环：初始状态下，假设起点为S。现设两个指针t和h，将它们均指向S。接着，让t和h同时以不同的速度向前推进：t速度为v，h速度为2v。当h无法向前推进时，即可确定没有环；如果t与h相遇，则可以确定有环。（注意，起点不一定在环上。） ####（2）如果有环，求环的起点；基本思想：在上述算法判断出存在环时，显然t和h在同一位置。此时，只要令h仍位于原来的位置M，而令t返回起点S，此时h与t之间距为环C长度的整数倍。随后，同时让t和h以相同的速度往前推进：即t每前进1步，h前进1步。持续该过程直至t与h再一次相遇，此相遇地点即为环C的一个起点P。 很多小伙伴看到这儿会很困惑，为毛是这样呢？我们可以用图来解释一下。 已经确定有环，设起点到环的起点距离为m，环的周长为n，第一次相遇时距离环的起点的距离为k，第一次相遇时慢指针在环上转了a圈，快指针在环上转了b圈。（这里假定h的速度是t速度的2倍）两者第一次相遇时，慢指针移动的距离i为： i = m + an + k; 快指针速度是慢指针速度的2倍，故快指针移动的距离2i为： 2i = m + bn + k。两者相减得，i = (b-a)*n，即i是环长度的倍数。此时，按上述算法，令慢指针返回起点，两个指针均以慢指针的速度同时向前推进。当慢指针推进m时，会到达环的起点，此时快指针移动的总距离为 2i+m。考虑这个 2i+m，可以理解为从起点走m，到达环起点，然后走了整数倍的环长度，故最终快指针也会到达环起点（即快慢指指针在环起点相遇）。 ####（3）如果有环，求环的长度；基本思想：这个相对来说比较简单。只需要在快慢指针相遇时，保持一个指针不动，让另外一个指针向前推进，记录其步数。当两个指针再次相遇时，第二个指针推进的步数，即为环的长度。 ###3. 算法实现这里引用一个维基上的python的算法实现，其他语言的也类似。123456789101112131415161718192021222324252627282930313233343536373839def floyd(f, x0): # Main phase of algorithm: finding a repetition x_i = x_2i. # The hare moves twice as quickly as the tortoise and # the distance between them increases by 1 at each step. # Eventually they will both be inside the cycle and then, # at some point, the distance between them will be # divisible by the period λ. tortoise = f(x0) # f(x0) is the element/node next to x0. hare = f(f(x0)) while tortoise != hare: tortoise = f(tortoise) hare = f(f(hare)) # At this point the tortoise position, ν, which is also equal # to the distance between hare and tortoise, is divisible by # the period λ. So hare moving in circle one step at a time, # and tortoise (reset to x0) moving towards the circle, will # intersect at the beginning of the circle. Because the # distance between them is constant at 2ν, a multiple of λ, # they will agree as soon as the tortoise reaches index μ. # Find the position μ of first repetition. mu = 0 tortoise = x0 while tortoise != hare: tortoise = f(tortoise) hare = f(hare) # Hare and tortoise move at same speed mu += 1 # Find the length of the shortest cycle starting from x_μ # The hare moves one step at a time while tortoise is still. # lam is incremented until λ is found. lam = 1 hare = f(tortoise) while tortoise != hare: hare = f(hare) lam += 1 return lam, mu ###4. 算法复杂度时间复杂度: 注意到当指针t到达环C的起点时(此时指针h显然在环C上)，之后指针t最多仅可能走1圈。若设起点S到环起点P距离为 m，环C的长度为 n，则时间复杂度为O(m+n)，是线性时间的算法。 空间复杂度： 仅需要创立指针t、指针h，保存环长n、环的一个起点P。空间复杂度为 O(1)，是常数空间的算法。 最后，说一下，大多数情况下，判断是否有环的问题，也可以用HashSet来实现，即每次用HashSet记录出现过的节点，当一个节点重复出现时，即可判断存在环。HashSet这种方法的空间复杂度为O(n), 故从空间复杂度的角度考虑，Floyd判圈算法要优于HashSet这种方法。 参考资料： https://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare https://zh.wikipedia.org/wiki/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95 https://stackoverflow.com/questions/2936213/explain-how-finding-cycle-start-node-in-cycle-linked-list-work]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie(Prefix Tree)前缀树]]></title>
    <url>%2F2017%2F08%2F28%2F%E5%89%8D%E7%BC%80%E6%A0%91%2F</url>
    <content type="text"><![CDATA[##1. 什么是Trie? Trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。Trie可以看作是一个确定有限状态自动机，尽管边上的符号一般是隐含在分支的顺序中的。 ##2. Trie的应用 (1) 自动补全例如,你在百度搜索的输入框中,输入一个单词的前半部分,它能够自动补全出可能的单词结果。(2) 拼写检查例如,在word中输入一个拼写错误的单词, 它能够自动检测出来。(3) IP路由表在IP路由表中进行路由匹配时, 要按照最长匹配前缀的原则进行匹配。(4) T9预测文本在大多手机输入法中, 都会用9格的那种输入法. 这个输入法能够根据用户在9格上的输入,自动匹配出可能的单词。(5) 填单词游戏相信大多数人都玩过那种在横竖的格子里填单词的游戏。 ##3. Trie的相关操作 ###(1)Trie的结点结构 根结点一般为空 每个结点最多有R个孩子,每个孩子分别对应字母表数据集中的一个字母(通常情况下,R为26,字母表为26个英文字母 ). 每个结点都有一个boolean类型的域, 代表这个结点是否是一个key的末尾.1234567891011121314151617181920212223242526272829class TrieNode &#123; // R links to node children private TrieNode[] links; private final int R = 26; private boolean isEnd; public TrieNode() &#123; links = new TrieNode[R]; &#125; public boolean containsKey(char ch) &#123; return links[ch -'a'] != null; &#125; public TrieNode get(char ch) &#123; return links[ch -'a']; &#125; public void put(char ch, TrieNode node) &#123; links[ch -'a'] = node; &#125; public void setEnd() &#123; isEnd = true; &#125; public boolean isEnd() &#123; return isEnd; &#125;&#125; ###(2) 向trie中插入一个关键字基本思想:从根结点开始, 向下依次寻找当前结点的link中, 是否有与关键字key中相应位置的字母相同的link; 如果有:沿着该link到下一层继续寻找; 如果没有: 则新建一个node, 插入当前结点的link中,然后沿link到下一层继续寻找； 向下遍历到key的末尾时, 修改该结点的boolean指示值,表示是关键字末尾.1234567891011121314151617181920class Trie &#123; private TrieNode root; public Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. public void insert(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char currentChar = word.charAt(i); if (!node.containsKey(currentChar)) &#123; node.put(currentChar, new TrieNode()); &#125; node = node.get(currentChar); &#125; node.setEnd(); &#125;&#125; 时间复杂度O(m), m是关键字字符串的长度; 空间复杂度也为O(m), m是关键字字符串的长度. ###(3) 在trie中查找一个关键字基本思想:从根结点开始, 根据关键字中的字母,沿着不同的link向下搜寻, 依次比较当前节点的link中是否有和关键字相应字母相同的link. 如果有,则继续到下一层搜寻 如果没有, 说明已经到一个单词的末尾. 此时看关键字是否遍历到了末尾,如果到了末尾的话, 说明匹配成功; 如果没有到末尾,说明只匹配到了关键字的一个前缀,匹配失败.123456789101112131415161718192021222324class Trie &#123; ... // search a prefix or whole key in trie and // returns the node where search ends private TrieNode searchPrefix(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char curLetter = word.charAt(i); if (node.containsKey(curLetter)) &#123; node = node.get(curLetter); &#125; else &#123; return null; &#125; &#125; return node; &#125; // Returns if the word is in the trie. public boolean search(String word) &#123; TrieNode node = searchPrefix(word); return node != null &amp;&amp; node.isEnd(); &#125;&#125; 时间复杂度O(m), m是关键字字符串长度；空间复杂度O(1). ###(4) 在trie中查找一个关键字是否是前缀这个操作和(3)在trie中查找一个关键字很相似, 不同的是, 这里的关键字不必是某个单词的末尾, 只需是前缀即可.12345678910class Trie &#123; ... // Returns if there is any word in the trie // that starts with the given prefix. public boolean startsWith(String prefix) &#123; TrieNode node = searchPrefix(prefix); return node != null; &#125;&#125; 时间复杂度O(m), m是关键字字符串长度；空间复杂度O(1). ##4. Trie的优点 还有其他几种数据结构，如平衡树和哈希表，它们可以在字符串数据集中搜索一个单词。那为什么我们还需要trie？虽然哈希表在查找某个关键字时有O（1）的时间复杂度，但以下操作效率不高： 用共同的前缀查找所有的键。 以字典顺序列举字符串数据集。 trie优于哈希表的另一个原因是，随着哈希表的大小增加，会有很多哈希冲突，搜索时间复杂度可能会恶化到 O（n），其中n是插入的f关键字的数量。当存储具有相同前缀的多个关键字时，Trie可以使用比哈希表少的空间。在这种情况下，使用trie只有O（m）时间复杂度，其中m是关键字长度。而在平衡树中查找关键字的时间复杂度为 O（mlogn）。 参考资料: https://en.wikipedia.org/wiki/Trie https://leetcode.com/articles/implement-trie-prefix-tree/]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2017%2F07%2F15%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分查找对于学过数据结构或者算法的人来说，应该是非常熟悉的。其基本思想是：比较目标（target）和中间关键字的大小关系，如果二者相等，则查找完毕；如果二者不等，则可以根据二者的大小关系，将查找的范围减半。 虽然二分查找的算法很简单，但是对于一个code新手来说，正确无误地实现一个二分查找算法也不是那么容易的。最近，刷了几道二分查找的题目，将刷题的一点收获整理如下： ####1．二分查找算法适用的范围：①必须是顺序表，不适用于链式存储②查找之前，序列必须是有序的。对于无序的序列，可以先采用合适的排序算法进行排序后，再使用二分查找。 ####2．二分查找算法的基本模式：递归方式：12345678910int binary_search(const int[] arr,int start,int end,int khey)&#123; if(start &gt; end) return -1; int mid = start + (end - start) / 2; if(arr[mid] &gt; khey) return binary_search(arr,start,mid-1,khey); if(arr[mid] &lt; khey) return binary_search(arr,mid+1,end,khey); return mid;//最后检测相等是因为大多数情况下是小于或者大于&#125; 非递归方式：（更常用）12345678910111213int binary_search(const int[] arr,int start,int end,int khey)&#123; int mid; while(start &lt;= end)&#123; mid = start + (end - start) / 2; if(arr[mid] &lt; khey) start = mid +1; else if(arr[mid] &gt; khey) end = mid - 1; else return mid; &#125; return -1;&#125; 其中，需要注意的地方有：① 我们学习二分算法的时候，求mid可能会用：mid = （start + end）/2，这时，在计算start+end的时候，可能会产生溢出，故以上所写的两种方式，均采用start + （end - start） / 2的方式，有时候可以避免溢出。②在非递归算法中，while循环中究竟应该是（start &lt; end）还是（start &lt;= end），这应该具体情况具体分析；③对于mid和khey比较的三种情况（大于，小于，相等）的排列顺序，大多数情况下，是影响不大的，实际中，可以根据三种情况出现的概率，决定其顺序；④以上仅仅是二分查找算法的模板，具体使用时应该具体情况具体分析，灵活运用。 ####3．二分查找的复杂度时间复杂度：O(logn)空间复杂度：O(1) 在有些地方你可能会看到三分查找(ternary search)，三分查找基本思想和二分查找一致，具体来讲：每次选出三分之一点和三分之二点，而不是中点，然后比较target和这两个点的大小关系，从而将查找的范围缩小至原来的三分之一。 二分查找和三分查找的空间复杂度都是O(1)，而二分查找的时间复杂度是O（log2n），三分查找的时间复杂度是O(log3n)。既然三分查找的时间复杂度要优于二分查找，那我们为什么不经常使用三分查找，而经常使用二分查找呢？原因在于在最坏情况下，三分查找要明显劣于二分查找。这个具体的推导过程就不详述了， 想了解的可以参考这道题目。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World !!!]]></title>
    <url>%2F2017%2F07%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[很早之前就想搭一个自己的博客，一直没有搞～ 之前写的一些文章，就直接放到了CSDN上。 最近看到了一个比较棒的博客，心里瞬间觉得自己也想搞一个。之后应该会陆续把一部分原先的文章迁过来，也会不定时更新一些新的技术文章，或者个人总结。 千里之行，始于足下～ 希望自己能够一直坚持下去～ 如果大家对我的博客有什么意见或者建议的话，欢迎通过邮箱lijinzhong2051@163.com联系我～]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
