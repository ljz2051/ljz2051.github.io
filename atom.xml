<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ljz-blog</title>
  
  <subtitle>爱学习、爱音乐、爱生活～</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-28T02:29:05.975Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Li Jinzhong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>回溯算法（Backtracking）</title>
    <link href="http://yoursite.com/2018/12/14/backtracking/"/>
    <id>http://yoursite.com/2018/12/14/backtracking/</id>
    <published>2018-12-14T07:12:12.000Z</published>
    <updated>2019-02-28T02:29:05.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Backtracking-回溯算法"><a href="#Backtracking-回溯算法" class="headerlink" title="Backtracking(回溯算法)"></a>Backtracking(回溯算法)</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。\<br>wikipedia : <a href="https://en.wikipedia.org/wiki/Backtracking" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Backtracking</a></p><h2 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2.适用场景"></a>2.适用场景</h2><p>一般来讲，会设置一个递归函数，函数的参数会携带一些当前的可能解的信息，根据这些参数得出可能解或者不可能而回溯. \<br>可以应用的场景有：N皇后、数独、集合等。\<br>回溯算法其实是暴力求解的一种优化。<br><a id="more"></a>     </p><h2 id="3-算法伪码"><a href="#3-算法伪码" class="headerlink" title="3.算法伪码"></a>3.算法伪码</h2><p>来自维基百科<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In order to apply backtracking to a specific class of problems, one must provide the data P for the particular instance of the problem that is to be solved, and six procedural parameters, root, reject, accept, first, next, and output. These procedures should take the instance data P as a parameter and should do the following:</span><br><span class="line"></span><br><span class="line">root(P): return the partial candidate at the root of the search tree.</span><br><span class="line">reject(P,c): return true only if the partial candidate c is not worth completing.</span><br><span class="line">accept(P,c): return true if c is a solution of P, and false otherwise.</span><br><span class="line">first(P,c): generate the first extension of candidate c.</span><br><span class="line">next(P,s): generate the next alternative extension of a candidate, after the extension s.</span><br><span class="line">output(P,c): use the solution c of P, as appropriate to the application.</span><br><span class="line">The backtracking algorithm reduces the problem to the call bt(root(P)), where bt is the following recursive procedure:</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">procedure bt(c)</span><br><span class="line">  <span class="keyword">if</span> reject(P,c) then <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> accept(P,c) then output(P,c)</span><br><span class="line">  s ← first(P,c)</span><br><span class="line">  <span class="keyword">while</span> s ≠ NULL do</span><br><span class="line">    bt(s)</span><br><span class="line">    s ← next(P,s)</span><br></pre></td></tr></table></figure><h2 id="4-例子"><a href="#4-例子" class="headerlink" title="4.例子"></a>4.例子</h2><p>leetcode 216题  <a href="https://leetcode.com/problems/combination-sum-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum-iii/</a></p><p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. \<br>Example 1: \<br>Input: k = 3, n = 7<br>Output: [[1,2,4]]  \<br>Example 2: \<br>Input: k = 3, n = 9<br>Output: [[1,2,6], [1,3,5], [2,3,4]]</p><p>BackTracking Solution:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backTracing(ans, <span class="keyword">new</span> ArrayList&lt;&gt;(), k, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracing</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; comb, <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comb.size() == k &amp;&amp; n == <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(comb);</span><br><span class="line">            ans.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comb.size() == k || n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="number">9</span> ; i++) &#123;</span><br><span class="line">                comb.add(i);</span><br><span class="line">                backTracing(ans, comb, k, n - i, i+<span class="number">1</span>);</span><br><span class="line">                comb.remove(comb.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Backtracking-回溯算法&quot;&gt;&lt;a href=&quot;#Backtracking-回溯算法&quot; class=&quot;headerlink&quot; title=&quot;Backtracking(回溯算法)&quot;&gt;&lt;/a&gt;Backtracking(回溯算法)&lt;/h1&gt;&lt;h2 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1. 定义&quot;&gt;&lt;/a&gt;1. 定义&lt;/h2&gt;&lt;p&gt;回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。\&lt;br&gt;wikipedia : &lt;a href=&quot;https://en.wikipedia.org/wiki/Backtracking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://en.wikipedia.org/wiki/Backtracking&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-适用场景&quot;&gt;&lt;a href=&quot;#2-适用场景&quot; class=&quot;headerlink&quot; title=&quot;2.适用场景&quot;&gt;&lt;/a&gt;2.适用场景&lt;/h2&gt;&lt;p&gt;一般来讲，会设置一个递归函数，函数的参数会携带一些当前的可能解的信息，根据这些参数得出可能解或者不可能而回溯. \&lt;br&gt;可以应用的场景有：N皇后、数独、集合等。\&lt;br&gt;回溯算法其实是暴力求解的一种优化。&lt;br&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/12/12/dfsandbfs/"/>
    <id>http://yoursite.com/2018/12/12/dfsandbfs/</id>
    <published>2018-12-12T07:43:59.421Z</published>
    <updated>2018-12-12T07:43:59.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树DFS和BFS-递归-非递归方式"><a href="#二叉树DFS和BFS-递归-非递归方式" class="headerlink" title="二叉树DFS和BFS 递归/非递归方式"></a>二叉树DFS和BFS 递归/非递归方式</h1><h2 id="1-DFS"><a href="#1-DFS" class="headerlink" title="1.DFS"></a>1.DFS</h2><p>DFS, 深度优先遍历 \<br>（1）递归形式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">traversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    list.add(root);</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)非递归形式 （利用栈来递归）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">traversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty()) &#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        res.add(node);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-BFS"><a href="#2-BFS" class="headerlink" title="2.BFS"></a>2.BFS</h2><p>BFS，广度优先遍历，对应二叉树的层级遍历 \<br>(1)非递归形式 （利用队列实现遍历）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">traversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> bfs(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">bfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if (root == null) return null;</span></span><br><span class="line">        <span class="keyword">int</span> curNum = <span class="number">1</span>;   <span class="comment">//维护当前层的node数量</span></span><br><span class="line">        <span class="keyword">int</span> nextNum = <span class="number">0</span>;  <span class="comment">//维护下一层的node数量</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            list.add(node);</span><br><span class="line">            curNum--;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                nextNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">                nextNum++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curNum == <span class="number">0</span>) &#123;</span><br><span class="line">                curNum = nextNum;</span><br><span class="line">                nextNum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>(2)递归形式 \<br>这里所谓的bfs递归形式，是利用dfs的递归形式，在递归过程中记录每个node的level，然后将属于一个level的node放到一list里面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;TreeNode&gt;&gt; traversal(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    List&lt;List&lt;TreeNode&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    dfs(root, <span class="number">0</span>, list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> level, List&lt;List&lt;TreeNode&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (level &gt;= list.size()) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; subList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        subList.add(root);</span><br><span class="line">        list.add(subList);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list.get(level).add(root);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left, level+<span class="number">1</span>, list);</span><br><span class="line">    dfs(root.right, level+<span class="number">1</span>, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><hr><br>图的深度优先遍历和广度优先遍历，和二叉树的dfs、bfs原理的相同的。一般，深度优先遍历利用栈来实现（或者递归），广度优先遍历利用队列来实现。</p><p>list.add(index, element):在index处添加元素element, 原先该位置的元素和后续的元素会后移<br>list.set(index, element):替换index处的元素，替换为element</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉树DFS和BFS-递归-非递归方式&quot;&gt;&lt;a href=&quot;#二叉树DFS和BFS-递归-非递归方式&quot; class=&quot;headerlink&quot; title=&quot;二叉树DFS和BFS 递归/非递归方式&quot;&gt;&lt;/a&gt;二叉树DFS和BFS 递归/非递归方式&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ljz</title>
    <link href="http://yoursite.com/2018/12/12/ljz/"/>
    <id>http://yoursite.com/2018/12/12/ljz/</id>
    <published>2018-12-12T07:42:13.000Z</published>
    <updated>2018-12-12T07:42:13.248Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>test_my_site</title>
    <link href="http://yoursite.com/2018/12/12/test-my-site/"/>
    <id>http://yoursite.com/2018/12/12/test-my-site/</id>
    <published>2018-12-12T07:24:19.000Z</published>
    <updated>2018-12-12T07:24:19.135Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World !!!</title>
    <link href="http://yoursite.com/2018/12/11/hello-world/"/>
    <id>http://yoursite.com/2018/12/11/hello-world/</id>
    <published>2018-12-11T04:04:19.389Z</published>
    <updated>2018-12-19T14:03:14.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World !!!"></a>Hello World !!!</h1><p>很早之前就想搭一个自己的博客，一直没有搞～ 之前写的一些文章，就直接放到了CSDN上。  最近看到了一个比较棒的博客，心里瞬间觉得自己也想搞一个。之后应该会陆续把一部分原先的文章迁过来，也会不定时更新一些新的技术文章，或者个人总结。<br><a id="more"></a></p><p>千里之行，始于足下～ 希望自己能够一直坚持下去～</p><p>如果大家对我的博客有什么意见或者建议的话，欢迎通过邮箱<a href="mailto:lijinzhong2051@163.com" target="_blank" rel="noopener">lijinzhong2051@163.com</a>联系我～</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World !!!&quot;&gt;&lt;/a&gt;Hello World !!!&lt;/h1&gt;&lt;p&gt;很早之前就想搭一个自己的博客，一直没有搞～ 之前写的一些文章，就直接放到了CSDN上。  最近看到了一个比较棒的博客，心里瞬间觉得自己也想搞一个。之后应该会陆续把一部分原先的文章迁过来，也会不定时更新一些新的技术文章，或者个人总结。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
