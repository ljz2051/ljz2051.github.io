<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ljz-blog</title>
  
  <subtitle>爱学习、爱音乐、爱生活～</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-28T02:53:42.283Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Li Jinzhong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>回溯算法（Backtracking）</title>
    <link href="http://yoursite.com/2018/12/14/backtracking/"/>
    <id>http://yoursite.com/2018/12/14/backtracking/</id>
    <published>2018-12-14T07:12:12.000Z</published>
    <updated>2019-02-28T02:53:42.283Z</updated>
    
    <content type="html"><![CDATA[<!-- # Backtracking(回溯算法)--><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。\<br>wikipedia : <a href="https://en.wikipedia.org/wiki/Backtracking" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Backtracking</a><br><a id="more"></a>     </p><h2 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2.适用场景"></a>2.适用场景</h2><p>一般来讲，会设置一个递归函数，函数的参数会携带一些当前的可能解的信息，根据这些参数得出可能解或者不可能而回溯. \<br>可以应用的场景有：N皇后、数独、集合等。\<br>回溯算法其实是暴力求解的一种优化。 </p><h2 id="3-算法伪码"><a href="#3-算法伪码" class="headerlink" title="3.算法伪码"></a>3.算法伪码</h2><p>来自维基百科<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In order to apply backtracking to a specific class of problems, one must provide the data P for the particular instance of the problem that is to be solved, and six procedural parameters, root, reject, accept, first, next, and output. These procedures should take the instance data P as a parameter and should do the following:</span><br><span class="line"></span><br><span class="line">root(P): return the partial candidate at the root of the search tree.</span><br><span class="line">reject(P,c): return true only if the partial candidate c is not worth completing.</span><br><span class="line">accept(P,c): return true if c is a solution of P, and false otherwise.</span><br><span class="line">first(P,c): generate the first extension of candidate c.</span><br><span class="line">next(P,s): generate the next alternative extension of a candidate, after the extension s.</span><br><span class="line">output(P,c): use the solution c of P, as appropriate to the application.</span><br><span class="line">The backtracking algorithm reduces the problem to the call bt(root(P)), where bt is the following recursive procedure:</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">procedure bt(c)</span><br><span class="line">  <span class="keyword">if</span> reject(P,c) then <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> accept(P,c) then output(P,c)</span><br><span class="line">  s ← first(P,c)</span><br><span class="line">  <span class="keyword">while</span> s ≠ NULL do</span><br><span class="line">    bt(s)</span><br><span class="line">    s ← next(P,s)</span><br></pre></td></tr></table></figure><h2 id="4-例子"><a href="#4-例子" class="headerlink" title="4.例子"></a>4.例子</h2><p>leetcode 216题  <a href="https://leetcode.com/problems/combination-sum-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum-iii/</a></p><p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. \<br>Example 1: \<br>Input: k = 3, n = 7<br>Output: [[1,2,4]]  \<br>Example 2: \<br>Input: k = 3, n = 9<br>Output: [[1,2,6], [1,3,5], [2,3,4]]</p><p>BackTracking Solution:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backTracing(ans, <span class="keyword">new</span> ArrayList&lt;&gt;(), k, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTracing</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; comb, <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comb.size() == k &amp;&amp; n == <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(comb);</span><br><span class="line">            ans.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comb.size() == k || n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="number">9</span> ; i++) &#123;</span><br><span class="line">                comb.add(i);</span><br><span class="line">                backTracing(ans, comb, k, n - i, i+<span class="number">1</span>);</span><br><span class="line">                comb.remove(comb.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- # Backtracking(回溯算法)--&gt;
&lt;h2 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1. 定义&quot;&gt;&lt;/a&gt;1. 定义&lt;/h2&gt;&lt;p&gt;回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。\&lt;br&gt;wikipedia : &lt;a href=&quot;https://en.wikipedia.org/wiki/Backtracking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://en.wikipedia.org/wiki/Backtracking&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树DFS和BFS 递归/非递归方式</title>
    <link href="http://yoursite.com/2018/12/13/dfsandbfs/"/>
    <id>http://yoursite.com/2018/12/13/dfsandbfs/</id>
    <published>2018-12-13T01:35:23.000Z</published>
    <updated>2019-02-28T02:54:12.304Z</updated>
    
    <content type="html"><![CDATA[<!-- # 二叉树DFS和BFS 递归/非递归方式--><h2 id="1-DFS"><a href="#1-DFS" class="headerlink" title="1.DFS"></a>1.DFS</h2><p>DFS, 深度优先遍历 \<br>（1）递归形式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">traversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    list.add(root);</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)非递归形式 （利用栈来递归）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">traversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty()) &#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        res.add(node);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-BFS"><a href="#2-BFS" class="headerlink" title="2.BFS"></a>2.BFS</h2><p>BFS，广度优先遍历，对应二叉树的层级遍历 \<br>(1)非递归形式 （利用队列实现遍历）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">traversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> bfs(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">bfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if (root == null) return null;</span></span><br><span class="line">        <span class="keyword">int</span> curNum = <span class="number">1</span>;   <span class="comment">//维护当前层的node数量</span></span><br><span class="line">        <span class="keyword">int</span> nextNum = <span class="number">0</span>;  <span class="comment">//维护下一层的node数量</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            list.add(node);</span><br><span class="line">            curNum--;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                nextNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">                nextNum++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curNum == <span class="number">0</span>) &#123;</span><br><span class="line">                curNum = nextNum;</span><br><span class="line">                nextNum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>(2)递归形式 \<br>这里所谓的bfs递归形式，是利用dfs的递归形式，在递归过程中记录每个node的level，然后将属于一个level的node放到一list里面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;TreeNode&gt;&gt; traversal(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    List&lt;List&lt;TreeNode&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    dfs(root, <span class="number">0</span>, list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> level, List&lt;List&lt;TreeNode&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (level &gt;= list.size()) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; subList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        subList.add(root);</span><br><span class="line">        list.add(subList);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list.get(level).add(root);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left, level+<span class="number">1</span>, list);</span><br><span class="line">    dfs(root.right, level+<span class="number">1</span>, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><hr><br>图的深度优先遍历和广度优先遍历，和二叉树的dfs、bfs原理的相同的。一般，深度优先遍历利用栈来实现（或者递归），广度优先遍历利用队列来实现。</p><p>list.add(index, element):在index处添加元素element, 原先该位置的元素和后续的元素会后移<br>list.set(index, element):替换index处的元素，替换为element</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- # 二叉树DFS和BFS 递归/非递归方式--&gt;
&lt;h2 id=&quot;1-DFS&quot;&gt;&lt;a href=&quot;#1-DFS&quot; class=&quot;headerlink&quot; title=&quot;1.DFS&quot;&gt;&lt;/a&gt;1.DFS&lt;/h2&gt;&lt;p&gt;DFS, 深度优先遍历 \&lt;br&gt;（1）递归形式&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x) &amp;#123; val = x; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java堆上的对象</title>
    <link href="http://yoursite.com/2018/12/12/jvm%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/12/12/jvm中的对象/</id>
    <published>2018-12-12T07:42:53.000Z</published>
    <updated>2019-02-28T03:17:28.223Z</updated>
    
    <content type="html"><![CDATA[<!--# Java堆上的对象--><h2 id="1-对象的创建（new-Object）"><a href="#1-对象的创建（new-Object）" class="headerlink" title="1.对象的创建（new Object）"></a>1.对象的创建（new Object）</h2><ul><li>创建过程：先检查能否在常量池中定位到一个类的符号引用，并且检查其代表的类是否被加载、解析和初始化过；若无，执行类加载过程；然后为新生对象分配内存（类加载完成后即可确定对象大小）;内存分配完后，内存空间初始化为零；接下来，对对象的类信息、类的元数据信息、对象哈希码、GC分代年龄进行设置（这些信息存放在对象头中（Object Header））；然后执行\&lt;init>方法（按照程序员的意愿进行初始化）;<a id="more"></a></li><li>java堆上内存分配的两种方式：”指针碰撞“（中间一个指针作为空闲内存和用过内存的分界点）、”空闲列表“（列表记录哪些内存块可用），采用哪种方式取决于垃圾收集器是否带有压缩整理功能。 分配内存时考虑线程安全问题：CAS失败重试，或者使用本地线程分配缓冲（TLAB）(类似于ThreadLocal)<h2 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2.对象的内存布局"></a>2.对象的内存布局</h2></li><li>3个区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）.</li><li>对象头； 两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等；另一部分是类型指针，即对象指向类元数据的指针。 如果对象是Java数组，对象头中需要记录数组长度<h2 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3.对象的访问定位"></a>3.对象的访问定位</h2>通过栈上reference数据来操作，主流的访问方式两种：</li><li>句柄：reference存储的是句柄地址，句柄池中的句柄包含了对象实例数据和类型数据的地址信息</li><li>直接指针访问：reference中存放的直接就是对象地址。</li><li>对比：句柄方式稳定，对象移动时，只需改变句柄中的实例数据指针，reference不用变；直接指针方式速度更快，因为节省了一次指针定位的时间开销。Sun HotSpot使用指针方式。</li></ul><hr><p>String.intern()是一个Native方法，作用：若字符串常量池中已经包含了一个等于String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。\<br>StirngBuilder创建的字符串实例在Java堆上。</p>]]></content>
    
    <summary type="html">
    
      &lt;!--# Java堆上的对象--&gt;
&lt;h2 id=&quot;1-对象的创建（new-Object）&quot;&gt;&lt;a href=&quot;#1-对象的创建（new-Object）&quot; class=&quot;headerlink&quot; title=&quot;1.对象的创建（new Object）&quot;&gt;&lt;/a&gt;1.对象的创建（new Object）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;创建过程：先检查能否在常量池中定位到一个类的符号引用，并且检查其代表的类是否被加载、解析和初始化过；若无，执行类加载过程；然后为新生对象分配内存（类加载完成后即可确定对象大小）;内存分配完后，内存空间初始化为零；接下来，对对象的类信息、类的元数据信息、对象哈希码、GC分代年龄进行设置（这些信息存放在对象头中（Object Header））；然后执行\&amp;lt;init&gt;方法（按照程序员的意愿进行初始化）;
    
    </summary>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>java虚拟机运行时内存区域</title>
    <link href="http://yoursite.com/2018/12/12/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2018/12/12/jvm内存区域/</id>
    <published>2018-12-12T02:24:19.000Z</published>
    <updated>2019-02-28T03:16:39.909Z</updated>
    
    <content type="html"><![CDATA[<!--# java虚拟机运行时内存区域 --><p>程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区 （前3个为线程私有，后2个为线程共享）</p><hr><h3 id="（1）程序计数器"><a href="#（1）程序计数器" class="headerlink" title="（1）程序计数器"></a>（1）程序计数器</h3><p>当前线程所执行的字节码的行号指示器；通过改变这个计数器的值来选取下一条需要执行的字节码指令；分支、循环、跳转、异常处理、线程恢复等功能依赖其完成；线程切换后能恢复到正确的执行位置，故每个线程需要一个独立的程序计数器，即“线程私有”.<br><a id="more"></a></p><h3 id="（2）Java虚拟机栈"><a href="#（2）Java虚拟机栈" class="headerlink" title="（2）Java虚拟机栈"></a>（2）Java虚拟机栈</h3><ul><li>Java Virtual Machine Stacks; 也就是通常所说的“栈”；线程私有；</li><li>存在数据结构–栈帧（Stack Frame）,用于存储局部变量表、操作数栈、方法出口等；局部变量表中存放了<strong>编译期可知</strong>的基本数据类型（boolean,int….）、对象引用（reference,可以理解为指向对象起始位置的引用指针，或者代表对象的句柄）</li><li>存在两种异常： 1）StackOverflowError(栈溢出)： 请求栈深度大于虚拟机栈深度  2）OutOfMemoryError(OOM): 动态扩展内存时，无法申请到足够的内存<h3 id="（3）本地方法栈"><a href="#（3）本地方法栈" class="headerlink" title="（3）本地方法栈"></a>（3）本地方法栈</h3>与虚拟机栈作用类似；虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机使用到底Native方法服务； 也会抛出StackOverflowError和OutOfMemoryError异常<h3 id="（4）Java堆"><a href="#（4）Java堆" class="headerlink" title="（4）Java堆"></a>（4）Java堆</h3></li><li>Java Heap；所有线程共享的一块内存区域；唯一目的：存放对象实例（对象实例和数组）；</li><li>java堆是垃圾收集器管理的主要区域；一般采用分代收集算法；细分为：新生代和老年代，再细致点有Eden空间、From Survivor空间、To Survivor空间等；某些情况下，Java堆坑可能划分出多个线程私有的分配缓冲区（TLAB）；</li><li>可以通过-Xmx和-Xms控制堆大小；当堆内存无法扩展时，会抛出OOM<h3 id="（5）方法区"><a href="#（5）方法区" class="headerlink" title="（5）方法区"></a>（5）方法区</h3></li><li>线程共享的内存区域；用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；在HotSpot虚拟机中称为“永久代”</li><li><strong>运行时常量池</strong>是方法区的一部分， 用于存放编译器生成的各种字面量和符号引用；运行时也可能将新的常量放入池中，例如String的intern()方法</li><li>jdk8取消了永久代，存储在永久代的部分数据就已经转移到Java Heap或者Native memory，符号引用(Symbols)转移到了native memory；<strong>字符串常量池(interned strings)转移到了Java heap</strong>；类的静态变量(class statics)转移到了Java heap;方法存放于元空间(Metaspace)</li></ul><p>注：直接内存（Direct Memory）：不是虚拟机中的内存区域；NIO中基于通道（Channel）和缓冲区（Buffer）的IO方式，可以使用Native函数库分配对外内存，然后通过DirectByteBuffer作为引用对其操作，不会收到堆大小的限制。</p>]]></content>
    
    <summary type="html">
    
      &lt;!--# java虚拟机运行时内存区域 --&gt;
&lt;p&gt;程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区 （前3个为线程私有，后2个为线程共享）&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;（1）程序计数器&quot;&gt;&lt;a href=&quot;#（1）程序计数器&quot; class=&quot;headerlink&quot; title=&quot;（1）程序计数器&quot;&gt;&lt;/a&gt;（1）程序计数器&lt;/h3&gt;&lt;p&gt;当前线程所执行的字节码的行号指示器；通过改变这个计数器的值来选取下一条需要执行的字节码指令；分支、循环、跳转、异常处理、线程恢复等功能依赖其完成；线程切换后能恢复到正确的执行位置，故每个线程需要一个独立的程序计数器，即“线程私有”.&lt;br&gt;
    
    </summary>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Hello World !!!</title>
    <link href="http://yoursite.com/2018/12/10/hello-world/"/>
    <id>http://yoursite.com/2018/12/10/hello-world/</id>
    <published>2018-12-10T00:43:34.000Z</published>
    <updated>2019-02-28T02:58:42.414Z</updated>
    
    <content type="html"><![CDATA[<!-- # Hello World !!!--><p>很早之前就想搭一个自己的博客，一直没有搞～ 之前写的一些文章，就直接放到了CSDN上。  最近看到了一个比较棒的博客，心里瞬间觉得自己也想搞一个。之后应该会陆续把一部分原先的文章迁过来，也会不定时更新一些新的技术文章，或者个人总结。</p><p>千里之行，始于足下～ 希望自己能够一直坚持下去～</p><a id="more"></a><p>如果大家对我的博客有什么意见或者建议的话，欢迎通过邮箱<a href="mailto:lijinzhong2051@163.com" target="_blank" rel="noopener">lijinzhong2051@163.com</a>联系我～</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- # Hello World !!!--&gt;
&lt;p&gt;很早之前就想搭一个自己的博客，一直没有搞～ 之前写的一些文章，就直接放到了CSDN上。  最近看到了一个比较棒的博客，心里瞬间觉得自己也想搞一个。之后应该会陆续把一部分原先的文章迁过来，也会不定时更新一些新的技术文章，或者个人总结。&lt;/p&gt;
&lt;p&gt;千里之行，始于足下～ 希望自己能够一直坚持下去～&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
